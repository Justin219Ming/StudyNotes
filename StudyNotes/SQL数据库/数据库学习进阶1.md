## MySQL体系结构
![](./截图文件夹/屏幕截图%202023-07-18%20082430.png)

- 连接层  校验用户名和密码，校验用户的权限
- 服务层 SQL接口，SQL的分析和优化，跨乘除引擎的功能也在这一层实现，如 过程和函数   
- 引擎层 负责MYSQL中数据的存储和提取。
- 存储层 将数据存储在系统文件中

## 存储引擎
**存储引擎** 是存储数据，建立索引、更新、查询数据等技术的实现方式。

在一个数据库下可以有多个存储引擎，所以存储引擎是表类型的。

- 创建表的时候指定存储引擎
```sql
create table 表名(
    字段1 字段1类型,
    字段2 字段2类型
)ENGINE = INNODB [comment 表注释];
```

- 查看当前数据库支持的存储引擎
  `show engines`

### 存储引擎特点
- InnoDB 
    支持事务，行级锁，外键
    对事务和数据完整性要求较高的核心数据
![](./截图文件夹/屏幕截图%202023-07-18%20085459.png)

- MyISAM 
  不支持事务，外键，行锁
  支持表锁
  如果应用以读操作和插入操作为主，只有很少的更新和删除操作，这个比较合适

- Memory
  表数据存储在内存中，由于受到硬件问题，或者断电情况，只能将这些表作为临时文件
  访问速度快，但是对表的大小有限制

*内存指的是高速缓存等，innoDB存储在磁盘属于外存*

![](./截图文件夹/屏幕截图%202023-07-18%20090036.png)

##### 存储引擎选择
根据应用系统的特点选择合适的存储引擎

### 索引
索引是帮助MySQL**高效获取数据**的**数据结构（有序）**
- 优点：提高数据检索效率，降低数据排序成本

- 缺点：降低更新表的速度，需要额外的空间来存储索引

#### 索引结构
![](./截图文件夹/屏幕截图%202023-07-18%20094710.png)

#### Btree
- 二叉树：顺序插入时，会形成一个链表，查询性能很差。大数据量情况下，层级深，检索速度慢
- 红黑树：大数据量情况下，层级深，检索速度慢
- B-tree (多路平衡查找树)：

![](./截图文件夹/屏幕截图%202023-07-18%20100030.png)

- B+树
相对于b树，所有数据会出现在叶子结点，并且形成一个单向链表
![](./截图文件夹/屏幕截图%202023-07-18%20100809.png)

- mysql中的B+树

![](./截图文件夹/屏幕截图%202023-07-18%20102951.png)

- hash
1. 只能用于等值比较，不能范围查询
2. 无法利用索引完成排序操作
3. 查询效率高于B+tree

![](./截图文件夹/屏幕截图%202023-07-18%20103633.png)

存储引擎支持情况：
1. Memory
2. InnoDB具有自适应hash功能，hash索引根据B+tree索引在指定条件下自动构建

### 为什么InnoDB选择使用B+Tree索引结构？
- 相对于二叉树，层级更少，搜索效率更高；
- B树，无论是叶子结点还是非叶子结点**都会保存数据**，这样导致**一页**中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低
- hash索引不支持范围搜索

#### 索引分类
![](./截图文件夹/屏幕截图%202023-07-18%20110604.png)

![](./截图文件夹/屏幕截图%202023-07-18%20110956.png)

- 聚集索引（只会有一个） 在叶子结点上挂着对应的行数据
- 二级索引 在叶子结点上挂着的是对应的聚集索引的叶子结点的主键值

##### 回表查询
先通过二级索引找到对应的主键值，再通过聚集索引利用主键值找到对应的行数据

### 索引语法
- 创建索引
```sql
create [unique | fulltext] index index_name on table_name(index_col_name,...);
```
- 查看索引
```sql
show index from table_name;
```
- 删除索引
```sql
drop index index_name on table_name;
```

## SQL性能分析
- SQL执行频率(七个下划线通配符)
`show global status like Com_______`

#### 慢查询日志
![](./截图文件夹/屏幕截图%202023-07-18%20114707.png)
配置完成之后需要重启mysql

*用来定位哪些sql语句运行时间过长*

- 查看慢查询日志是否开启
`show variables like 'slow_query_log'`

- 重启mysql服务器
`systemctl restart mysqld`

#### profile详情
show profile 能够在做sql优化时帮助我们了解时间都耗费到哪里去了

- 操作
```sql
-- 查看是否支持profile
select @@having_profiling

-- 默认profile是关闭的,查看是否开启
select @@profiling;

-- set开启
set profiling = 1;

-- 显示当前会话所有语句的耗时,并展示对应id
show profiles;

-- 查看指定ID的sql语句的各个阶段的耗时情况
show profile for query ID;

-- 查看指定ID的sql语句的各个阶段的耗cpu情况
show profile cpu for query ID;
```

### explain执行计划
用来获取mysql如何执行select语句的信息

*只需要在正常的select语句前面加explain就可以了*

- 语法
```sql
exlplain select 字段列表 from 表名 where 条件;
```  

![](./截图文件夹/屏幕截图%202023-07-19%20140129.png)
- possible_key 这个表可能使用到的索引
![](./截图文件夹/屏幕截图%202023-07-19%20140347.png)

### 索引使用
- 最左前缀法则
> 如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列，如果跳过某一列，索引将部分失效（后面字段的索引失效）

#### 索引失效情况
- 范围查询
> 在联合索引总，出现范围查询，**范围查询右侧的列索引失效**，可以使用>= 或者 <= 来**规避**。

- 索引列运算,以字符串的前几个字符为条件的查询语句
`explain select * from 表名 where substring(phone,10,2) = '15';`

- 字符串没有使用单引号
- 头部模糊匹配会失效，**尾部模糊查询**不会失效
- or前后两个索引都存在才能正常使索引
- 数据分布的影响，如果mysql评估使用索引比全表更慢，则不使用索引 

*猜测数据分布应该是在一半作为分界线*

#### SQL提示
在SQL语句中加入人为的提示来达到优化的目的
- use index   建议
- ignore index   忽略
- force index   强制

语法
```sql
explain select * from 表名 [use|ignore|force] index (索引名字) where ...;
```

#### 覆盖索引
*在使用`select *`的时候很容易出现回表查询导致效率变低，关键在于你的索引表是怎么建立的*
  
#### 前缀索引
将字符串的一部分前缀，建立索引，从而节省大量空间，提高索引效率

- 创建的语法
```sql
-- n表示你要提取这个字符串的前n个字符
create index idx_xxxx on table_name (column(n));
```
- 前缀长度
> 可以通过两个公式来求出当前索引值和总数据表的比值，如果比值为1代表每一条信息都不相同
```sql
-- 计算比值
select count(distinct 表名) / count(*) from 表名;

-- 计算前n个字符的比值
select count(distinct substring(字段名,1,n)) / count(*) from 表名;
```

#### 索引设计原则
![](./截图文件夹/屏幕截图%202023-07-20%20091737.png)

## SQL优化
#### 插入数据
- insert优化
  1. 批量插入
  2. 手动提交事务
  3. 主键顺序插入

- 大批量插入数据
![](./截图文件夹/屏幕截图%202023-07-20%20093220.png)

#### 主键优化
插入时最好按主键顺序插入，否则出现**页分裂**现象会降低效率

在删除过程中，当页中的记录达到默认设置的值时，innodb会在前后两页中寻找是否可以自动完成**页合并**的优化

- 满足业务需求的情况下，尽量降低主键的长度
- 插入数据时，尽量顺序插入，使用自增主键
- 业务操作时，避免对主键的修改

#### order by
![](./截图文件夹/屏幕截图%202023-07-20%20102716.png)
![](./截图文件夹/屏幕截图%202023-07-20%20103520.png)
- 遵循最左前缀法则

#### group by
![](./截图文件夹/屏幕截图%202023-07-20%20104647.png)

#### limit
![](./截图文件夹/屏幕截图%202023-07-20%20111903.png)

#### count
![](./截图文件夹/屏幕截图%202023-07-20%20113947.png)

#### update
InnoDB的行锁是针对索引假的锁，不是针对记录加的锁，如果索引失效，那么行锁会升级为表锁。