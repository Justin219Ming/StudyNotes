# CMake
### 说明
CMake能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性。

*类似与makefile的功能，告诉操作系统我的库文件如何进行编译和链接，但CMake实际上是先 生成了一个makefile文件*

![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20115128.png)

*关于cmake的实际使用还需要再去查阅一下资料，以下内容仅仅用于学习cmake*

### 语法
#### 注释

![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20115210.png)

## CMakeLists.txt
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20115342.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20115449.png)

**cmake 命令的参数必须是CMakeLists.txt 文件所在的路径**，可以创建一个新文件夹用来放置编译出来的文件。

#### set
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20120225.png)

**使用set的取值，记得上面标红的格式， `${ }`**

#### 指定C++标准
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20120839.png)

#### 指定输出位置
**最好使用绝对路径**
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20121115.png)

### 搜索文件
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20125609.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20125623.png)

**实例**
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20130359.png)

**其中的`PROJECT_SOURCE_DIR` 和 `CMAKE_CURRENT_SOURCE_DIR`都是用来指代CMakeLists文件所在位置的路径**

### 指定头文件的路径
*注意这里是指定头文件的目录的路径，而不是具体的某个头文件*
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20131055.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20131111.png)

### 制作动态库和静态库
*这个东西的作用在于你生成的库都是二进制文件，别人是没有办法知道你原代码是什么样子的，这样就相当于一次加密的行为*

*库文件就是包含了你所写的函数还有头文件之类的东西*

#### 静态库
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20133342.png)


#### 动态库
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20133426.png)

#### 指定输出库文件的路径

![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20133538.png)

*和输出路径有关的这种东西，如果本身没有这个路径，cmake会自动创建这个路径*

### 链接静态库

![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20134855.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-24%20134929.png)

静态库和源文件都会被打包到应用程序中，动态库是在**应用程序调用对应的函数**了才开始加载到内存

### 链接动态库
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20091805.png)

*public权限类似c++，private权限不同与c++，最后一个权限传递的信息最少*

*动态库在进程需要**调用其中的函数**的时候会加载到进程的虚拟内存空间中，所以动态库可以同时被多个进程调用*

**动态库和静态库的区别**
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20093043.png)

动态库的链接通常写在生成执行程序的后面

![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20093154.png)

*如果需要链接多个动态库，在相应的语法后面用空格隔开就可以*

#### 链接自己编写的动态库需要表明路径所在

![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20094242.png)

### 日志
*也就是一种调试的办法，类似于c中的printf 和 rust中的println,可以利用 `${}` 来打印变量的信息，但是这个不同的参数可以决定是否中断程序*

![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20094455.png)

### 变量操作
- set追加
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20102345.png)

- list追加

![](../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20102434.png)

- list移除

![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20102659.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20102743.png)

- list的其他用法

![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20103153.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20103232.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20103254.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20103313.png)

### 宏
*利用宏的原因在于，在程序编写过程中会用到大量printf来进行打印测试，如果程序编写好了，再一条条删除非常麻烦，这时候宏的作用就体现出来了*

![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20103720.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20103915.png)

### 系统自定义好的宏
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20104107.png)

**关于更加贴近现实的例子，也就是嵌套定义cmake，详情见**
https://subingwen.cn/cmake/CMake-advanced/

**也可以参考b站视频**
https://www.bilibili.com/video/BV14s4y1g7Zj?p=17&spm_id_from=pageDriver&vd_source=6145f2ccf40a9f978a5b12b81fe169f0

以下是截图
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20115001.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20115224.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20115359.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20115429.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20115506.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20115533.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20115559.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20115634.png)
![](./../SQL数据库/截图文件夹/屏幕截图%202023-07-25%20115657.png)

**静态库可以链接静态库，也可以链接动态库**